#!/usr/bin/env python3

'''
The programs in this library are for finding overlapping clusters of LSVs to be used for SVR formulation
 prior to co-splicing network inference. Data comes from TSV files generated by MAJIQ framework.
'''

import argparse

# Get most up and downstream positions of current LSV (and sort)
def get_lsv_boundary(coords):

    positions = []
  
    for j in coords:
        pos = j.split('-')
        positions.append(int(pos[0]))
        positions.append(int(pos[1]))

    sorted_positions = sorted(positions)

    return (sorted_positions[0], sorted_positions[-1])

# Parse LSVs and collect their coordinates        
def get_lsv_coords(fn):

    with open(fn, 'r') as fh:
        lines = [l.strip().split('\t') for l in fh.readlines()]

    gene_dict = {}

    for l in lines:
        gene = l[0].split(':')[0]
        if gene not in gene_dict:
            gene_dict[gene] = {}
        lsv = l[0]
        jCoords = l[1].split(';')        
        # Add intron junction if LSV contains intron retention
        if len(l) == 3:
            jCoords.append(l[2])
        gene_dict[gene][lsv] = get_lsv_boundary(jCoords)
        
    return gene_dict    

# Group any overlapping LSVs into eventual SVRs
def merge_lsv_coordinates(intervals):

    sorted_by_lower_bound = sorted(intervals, key=lambda tup: tup[0])
    merged = []

    for higher in sorted_by_lower_bound:
        if not merged:
            merged.append(higher)
        else:
            lower = merged[-1]
            # test for intersection between lower and higher:
            # we know via sorting that lower[0] <= higher[0]
            if higher[0] <= lower[1]:
                upper_bound = max(lower[1], higher[1])
                merged[-1] = (lower[0], upper_bound)  # replace by merged interval
            else:
                merged.append(higher)

    return merged

# For each gene, collect and merge overlapping LSVs
def gene_clusters(gene, lsv_set):

    # Define cluster regions first 
    cluster_coords = sorted(merge_lsv_coordinates([coords for coords in lsv_set.values()]))

    cluster_dict = {}

    n = 1
    for cluster in cluster_coords:
        cluster_dict[cluster] = gene + '_cluster_' + str(n)
        n = n + 1

    lsv_to_clust = {}

    # Parse lsvs
    for lsv,lsv_coords in lsv_set.items():
        s,e = lsv_coords[0], lsv_coords[1]
        # Parse cluster coordinates and see if lsv falls within them
        for clust_coords in cluster_coords:
            cS, cE = clust_coords[0], clust_coords[1]
            # When found, indicate in dictionary which cluster it belongs to
            if s >= cS and e <= cE:
                lsv_to_clust[lsv] = cluster_dict[clust_coords]
                break

    return lsv_to_clust    

# Parse gene dictionary and start looking for potential SVRs
def get_lsv_clusters(gene_dict):

    lsv_clusters = {}

    for gene,lsvs in gene_dict.items():
        for lsv,cluster in gene_clusters(gene, lsvs).items():
            lsv_clusters[lsv] = cluster

    return lsv_clusters

# Write to file (for debugging)
def write_lsv_clusters(lsv_clusters, fn):

    with open(fn, 'w') as fh:
        fh.write('LSV_ID,CLUSTER_ID\n')
        for lsv,clust in lsv_clusters.items():
            fh.write(lsv + ',' + clust + '\n')


if __name__ == "__main__":

    # Program Arguments (only for debugging, functions typically used as library)
    parser = argparse.ArgumentParser(description='Annotate Overlapping LSVs as Single Splice Variant Regions')
    requiredNamed = parser.add_argument_group('required arguments')
    requiredNamed.add_argument('--junc_coords', type=str, help='Tab delimited file of LSV IDs & junction coordinates (cut -f 3,15 from tsv file)', required=True)
    requiredNamed.add_argument('--outfile', type=str, help='File name (and path) of csv file mapping LSVs to splice variant regions.', required=True)
    args = parser.parse_args()

    # Get arguments
    fn = args.junc_coords
    of = args.outfile

    gene_dict = get_lsv_coords(fn)

    lsv_clusters = get_lsv_clusters(gene_dict)

    write_lsv_clusters(lsv_clusters, of)

